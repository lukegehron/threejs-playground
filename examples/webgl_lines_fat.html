<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - lines - fat</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">

		<script id="vertexShader" type="x-shader/x-vertex">
			varying vec2 vUv;
attribute float percent;
uniform float u_time;
uniform float number;
uniform float speed;
uniform float length;
varying float opacity;
uniform float size;

void main()
{
	vUv = uv;
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	float l = clamp(1.0-length,0.0,1.0);//空白部分长度

	gl_PointSize = clamp(fract(percent*number + l - u_time*number*speed)-l ,0.0,1.) * size * (1./length);

	opacity = gl_PointSize/size;
	gl_Position = projectionMatrix * mvPosition;
}
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
			#ifdef GL_ES
precision mediump float;
#endif

varying float opacity;
uniform vec3 color;

void main(){
	if(opacity <=0.2){
			discard;
	}
	gl_FragColor = vec4(color,1.0);
}
</script>
	</head>

	<body>

		<div id="container"></div>

		<div id="info"><a href="https://threejs.org" target="_blank">three.js</a> - fat lines</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';

			import { GUI } from './jsm/libs/dat.gui.module.js';
			import { OrbitControls } from './jsm/controls/OrbitControls.js';
			import { Line2 } from './jsm/lines/Line2.js';
			import { LineMaterial } from './jsm/lines/LineMaterial.js';
			import { LineGeometry } from './jsm/lines/LineGeometry.js';
			import { GeometryUtils } from './jsm/utils/GeometryUtils.js';

			let line, renderer, scene, camera, camera2, controls;
			let line1;
			let matLine, matLineBasic, matLineDashed;
			let stats;
			let gui;
			var commonUniforms;

			// viewport
			let insetWidth;
			let insetHeight;

			init();
			animate();

			function init() {

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setClearColor( 0x000000, 0.0 );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( - 40, 0, 60 );

				// camera2 = new THREE.PerspectiveCamera( 40, 1, 1, 1000 );
				// camera2.position.copy( camera.position );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 10;
				controls.maxDistance = 500;











				commonUniforms = {
            u_time:{ value: 0.0 }
        };

        let curve = new THREE.EllipseCurve(
            0,  0,            // ax, aY
            10, 10,           // xRadius, yRadius
            0, 2 * Math.PI,  // aStartAngle, aEndAngle
            false,            // aClockwise
            0                 // aRotation
        );
        initFlyLine(curve, {
            speed: 0.02,
            color: new THREE.Vector3(1.0,0.0,1.0),
            number: 1.0,
            length: 0.1,
            size:2.0
        },500);


        let curves = initCircleCurveGroup(5);

        for (let curve of curves){
            initFlyLine(curve,{
                speed: Math.random()*0.3+0.1,
                number: 1,// Math.floor(Math.random()*9+1)
                color: randomVec3Color(),
                size:4.0
            },4000)
        }

        // controls = new THREE.OrbitControls( camera, renderer.domElement );


        // onWindowResize();
        // window.addEventListener( 'resize', onWindowResize, false );

        // container.appendChild( renderer.domElement );


    // }


    // function animate() {
    //     requestAnimationFrame( animate );

    //     render();
    // }
    // 首先要写出一个使用fragmentshader生成的material并赋在点上


    function initLineMaterial(setting){
        let number = setting ? (Number(setting.number) || 1.0) : 1.0;
        let speed = setting ? (Number(setting.speed) || 1.0) : 1.0;
        let length = setting ? (Number(setting.length) || 0.5) : 0.5;
        let size = setting ?(Number(setting.size) || 3.0) : 3.0;
        let color = setting ? setting.color || new THREE.Vector3(0,1,1) : new THREE.Vector3(0,1,1);
        let singleUniforms = {
            u_time: commonUniforms.u_time,
            number: {type: 'f', value:number},
            speed: {type:'f',value:speed},
            length: {type: 'f', value: length},
            size: {type: 'f', value: size},
            color: {type: 'v3', value: color}
        };
        let lineMaterial = new THREE.ShaderMaterial({
            uniforms:singleUniforms,
            vertexShader:document.getElementById('vertexShader').textContent,
            fragmentShader:document.getElementById('fragmentShader').textContent,
            transparent:true,
            //blending:THREE.AdditiveBlending,
        });
        return lineMaterial;
    }


    function initCircleCurveGroup(number){
        let curves = [];

        for (let i = 0; i < number; i++){
            let curve = new THREE.EllipseCurve(
                0,  0,            // ax, aY
                Math.random()*20+5, Math.random()*20+5,           // xRadius, yRadius
                0, 2 * Math.PI,  // aStartAngle, aEndAngle
                false,            // aClockwise
                0                 // aRotation
            );
            curves.push(curve);
        }
        return curves;
    }

    function randomVec3Color(){
        return new THREE.Vector3(
            Math.random()*0.6 + 0.4,
            Math.random()*0.6 + 0.4,
            Math.random()*0.6 + 0.4
        )
    }
    // 根据curve和颜色 生成线条
    /**
     * @param curve {THREE.Curve} 路径,
     * @param matSetting {Object} 材质配置项
     * @param pointsNumber {Number} 点的个数 越多越细致
     * */
    function initFlyLine(curve,matSetting, pointsNumber){

        var points = curve.getPoints( pointsNumber );
      // console.log(pointsNumber)
        var geometry = new THREE.BufferGeometry().setFromPoints( points );

        let length = points.length;
        var percents = new Float32Array(length);
        for (let i = 0; i < points.length; i+=1){
            percents[i] = (i/length);
        }

        geometry.setAttribute('percent', new THREE.BufferAttribute(percents,1));

        let lineMaterial = initLineMaterial(matSetting);

        var flyLine = new THREE.Points( geometry, lineMaterial );
        let euler = new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI,0);
        flyLine.setRotationFromEuler(euler);
        scene.add(flyLine);
    }

    // function onWindowResize( event ) {
    //     renderer.setSize( window.innerWidth, window.innerHeight );
    //     camera.aspect = window.innerWidth / window.innerHeight;
    //     camera.updateProjectionMatrix();
    //     renderer.domElement.width = window.innerWidth;
    //     renderer.domElement.height = window.innerHeight;
    // }

    // function render() {
    //     commonUniforms.u_time.value +=0.01;
    //     renderer.render( scene, camera );
    // }







				// Position and THREE.Color Data

				const positions = [];
				const colors = [];

				const points = GeometryUtils.hilbert3D( new THREE.Vector3( 0, 0, 0 ), 20.0, 1, 0, 1, 2, 3, 4, 5, 6, 7 );

				const spline = new THREE.CatmullRomCurve3( points );
				const divisions = Math.round( 12 * points.length );
				const point = new THREE.Vector3();
				const color = new THREE.Color();

				for ( let i = 0, l = divisions; i < l; i ++ ) {

					const t = i / l;

					spline.getPoint( t, point );
					positions.push( point.x, point.y, point.z );

					color.setHSL( t, 1.0, 0.5 );
					colors.push( color.r, color.g, color.b );

				}


				// Line2 ( LineGeometry, LineMaterial )

				const geometry = new LineGeometry();
				geometry.setPositions( positions );
				geometry.setColors( colors );

				matLine = new LineMaterial( {

					color: 0xffffff,
					linewidth: 5, // in pixels
					vertexColors: true,
					//resolution:  // to be set by renderer, eventually
					dashed: false

				} );

				line = new Line2( geometry, matLine );
				line.computeLineDistances();
				line.scale.set( 1, 1, 1 );
				scene.add( line );


				// THREE.Line ( THREE.BufferGeometry, THREE.LineBasicMaterial ) - rendered with gl.LINE_STRIP

				const geo = new THREE.BufferGeometry();
				geo.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
				geo.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				matLineBasic = new THREE.LineBasicMaterial( { vertexColors: true } );
				matLineDashed = new THREE.LineDashedMaterial( { vertexColors: true, scale: 2, dashSize: 1, gapSize: 1 } );

				line1 = new THREE.Line( geo, matLineBasic );
				line1.computeLineDistances();
				line1.visible = false;
				scene.add( line1 );

				//

				window.addEventListener( 'resize', onWindowResize, false );
				onWindowResize();

				stats = new Stats();
				document.body.appendChild( stats.dom );

				initGui();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				insetWidth = window.innerHeight / 4; // square
				insetHeight = window.innerHeight / 4;

				// camera2.aspect = insetWidth / insetHeight;
				// camera2.updateProjectionMatrix();

			}

			function animate() {

				commonUniforms.u_time.value +=0.01;

				requestAnimationFrame( animate );

				stats.update();

				// main scene

				renderer.setClearColor( 0x000000, 0 );

				renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );

				// renderer will set this eventually
				matLine.resolution.set( window.innerWidth, window.innerHeight ); // resolution of the viewport

				renderer.render( scene, camera );

				// inset scene

				renderer.setClearColor( 0x222222, 1 );

				renderer.clearDepth(); // important!

				renderer.setScissorTest( true );

				renderer.setScissor( 20, 20, insetWidth, insetHeight );

				renderer.setViewport( 20, 20, insetWidth, insetHeight );

				// camera2.position.copy( camera.position );
				// camera2.quaternion.copy( camera.quaternion );

				// renderer will set this eventually
				matLine.resolution.set( insetWidth, insetHeight ); // resolution of the inset viewport

				// renderer.render( scene, camera2 );

				renderer.setScissorTest( false );

			}

			//

			function initGui() {

				gui = new GUI();

				const param = {
					'line type': 0,
					'width (px)': 5,
					'dashed': false,
					'dash scale': 1,
					'dash / gap': 1
				};

				gui.add( param, 'line type', { 'LineGeometry': 0, 'gl.LINE': 1 } ).onChange( function ( val ) {

					switch ( val ) {

						case '0':
							line.visible = true;

							line1.visible = false;

							break;

						case '1':
							line.visible = false;

							line1.visible = true;

							break;

					}

				} );

				gui.add( param, 'width (px)', 1, 10 ).onChange( function ( val ) {

					matLine.linewidth = val;

				} );

				gui.add( param, 'dashed' ).onChange( function ( val ) {

					matLine.dashed = val;

					// dashed is implemented as a defines -- not as a uniform. this could be changed.
					// ... or THREE.LineDashedMaterial could be implemented as a separate material
					// temporary hack - renderer should do this eventually
					if ( val ) matLine.defines.USE_DASH = ""; else delete matLine.defines.USE_DASH;
					matLine.needsUpdate = true;

					line1.material = val ? matLineDashed : matLineBasic;

				} );

				gui.add( param, 'dash scale', 0.5, 2, 0.1 ).onChange( function ( val ) {

					matLine.dashScale = val;
					matLineDashed.scale = val;

				} );

				gui.add( param, 'dash / gap', { '2 : 1': 0, '1 : 1': 1, '1 : 2': 2 } ).onChange( function ( val ) {

					switch ( val ) {

						case '0':
							matLine.dashSize = 2;
							matLine.gapSize = 1;

							matLineDashed.dashSize = 2;
							matLineDashed.gapSize = 1;

							break;

						case '1':
							matLine.dashSize = 1;
							matLine.gapSize = 1;

							matLineDashed.dashSize = 1;
							matLineDashed.gapSize = 1;

							break;

						case '2':
							matLine.dashSize = 1;
							matLine.gapSize = 2;

							matLineDashed.dashSize = 1;
							matLineDashed.gapSize = 2;

							break;

					}

				} );

			}

		</script>

	</body>

</html>
